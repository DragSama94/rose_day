<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>For Her Highness ðŸ‘‘ðŸŒ¹</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Monsieur+La+Doulaise&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050005; /* Deep Royal Purple/Black */
            font-family: 'Cinzel', serif;
        }

        canvas {
            position: fixed;
            top: 0; left: 0;
            z-index: 1;
        }

        /* --- UI OVERLAY --- */
        #ui-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
        }

        .header {
            text-align: center;
            opacity: 0;
            animation: fadeInDown 2s ease-out forwards 1s;
        }

        h1 {
            font-family: 'Monsieur La Doulaise', cursive;
            font-size: 5rem;
            color: #ff0055;
            margin: 0;
            text-shadow: 0 0 20px rgba(255, 0, 85, 0.5);
            line-height: 0.8;
        }

        h2 {
            font-size: 1rem;
            color: #d4af37; /* Gold */
            letter-spacing: 5px;
            text-transform: uppercase;
            margin-top: 10px;
        }

        .footer {
            text-align: center;
            opacity: 0;
            animation: fadeInUp 2s ease-out forwards 2s;
        }

        .instruction {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            letter-spacing: 2px;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        #click-trigger {
            pointer-events: auto;
            cursor: pointer;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5;
        }

        @keyframes fadeInDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }

        /* --- LOADING OVERLAY --- */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #d4af37;
            font-size: 1rem;
            letter-spacing: 5px;
            transition: opacity 1s;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">CONJURING MAGIC...</div>

    <div id="ui-layer">
        <div class="header">
            <h2>Happy Rose Day</h2>
            <h1>My Princess</h1>
        </div>
        <div class="footer">
            <div class="instruction">Tap screen to transform</div>
        </div>
    </div>

    <div id="click-trigger"></div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 25000, // HIGH DENSITY
            particleSize: 0.15,
            bloomStrength: 2.0, // Very dreamy
            bloomRadius: 0.5,
            colors: {
                rose: new THREE.Color('#ff0055'), // Deep Pink
                heart: new THREE.Color('#ff0000'), // Red
                gold: new THREE.Color('#ffaa00'), // Gold sparks
                void: 0x050005
            }
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.colors.void, 0.02);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 30);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enableZoom = false; // Keep the frame cinematic
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        
        // Attributes
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);
        const sizes = new Float32Array(CONFIG.particleCount);
        
        // Target Positions (Morphing Logic)
        const rosePositions = new Float32Array(CONFIG.particleCount * 3);
        const heartPositions = new Float32Array(CONFIG.particleCount * 3);
        
        // --- 1. GENERATE ROSE SHAPE ---
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;

            // Rose Math (Rhodonea Curve 3D)
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            // "k" determines petals. k=4 is classic.
            // We layer multiple sizes to create volume
            const rBase = 8; 
            const k = 3; 
            
            // Parametric Rose Equation
            let r = (Math.cos(k * theta * 2) + 2) * (Math.random() * 2 + 0.5);
            
            // Convert to Cartesian
            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi) * 0.5; // Flatten z slightly
            
            rosePositions[i3] = x;
            rosePositions[i3+1] = y;
            rosePositions[i3+2] = z;
            
            // Initial Position = Rose
            positions[i3] = x;
            positions[i3+1] = y;
            positions[i3+2] = z;

            // Colors (Mix of Pink and Gold)
            const isGold = Math.random() > 0.8;
            const c = isGold ? CONFIG.colors.gold : CONFIG.colors.rose;
            colors[i3] = c.r;
            colors[i3+1] = c.g;
            colors[i3+2] = c.b;
            
            sizes[i] = Math.random();
        }

        // --- 2. GENERATE HEART SHAPE ---
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            
            // Heart Math
            // x = 16sin^3(t)
            // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
            
            const t = Math.random() * Math.PI * 2;
            const scale = 0.5; // Scale down to fit screen
            
            // Add volume to the heart (randomness inside the shape)
            const v = Math.random(); 
            
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            let z = (Math.random() - 0.5) * 6; // Depth
            
            // Apply scale and randomize slightly to fill volume
            x *= scale * v;
            y *= scale * v;
            
            heartPositions[i3] = x;
            heartPositions[i3+1] = y + 2; // Shift up slightly
            heartPositions[i3+2] = z;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // --- SHADER MATERIAL (Sparkles) ---
        const material = new THREE.ShaderMaterial({
            uniforms: {
                pointTexture: { value: new THREE.TextureLoader().load('https://assets.codepen.io/127738/dotTexture.png') }, // Fallback texture or procedural
                uTime: { value: 0 }
            },
            vertexShader: `
                attribute float size;
                varying vec3 vColor;
                uniform float uTime;
                void main() {
                    vColor = color;
                    vec3 pos = position;
                    
                    // Add subtle breathing movement
                    float breath = sin(uTime * 2.0 + position.x) * 0.1;
                    pos += normal * breath;
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = size * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                void main() {
                    // Create soft circular particle
                    float d = distance(gl_PointCoord, vec2(0.5));
                    if(d > 0.5) discard;
                    
                    // Glow gradient
                    float alpha = 1.0 - (d * 2.0);
                    alpha = pow(alpha, 1.5);
                    
                    gl_FragColor = vec4(vColor, alpha);
                }
            `,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            transparent: true
        });

        // Use a simple circle canvas texture to avoid CORS issues if external image fails
        function getSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }
        material.uniforms.pointTexture.value = getSprite();

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.bloomStrength, CONFIG.bloomRadius, 0.1);
        composer.addPass(bloomPass);

        // --- INTERACTION & ANIMATION ---
        
        // Morph Logic
        let currentShape = 'rose'; // 'rose' or 'heart'
        
        function transformShape() {
            const target = currentShape === 'rose' ? heartPositions : rosePositions;
            const colorTarget = currentShape === 'rose' ? CONFIG.colors.heart : CONFIG.colors.rose;
            
            // Tween Positions
            const posAttr = geometry.attributes.position;
            
            // We use a dummy object to tween value 0 -> 1
            const tweenObj = { t: 0 };
            
            // Store start positions
            const startPositions = Float32Array.from(posAttr.array);
            
            new TWEEN.Tween(tweenObj)
                .to({ t: 1 }, 2500) // 2.5 seconds
                .easing(TWEEN.Easing.Elastic.Out) // Bouncy effect
                .onUpdate(() => {
                    for(let i=0; i<CONFIG.particleCount; i++) {
                        const i3 = i*3;
                        posAttr.array[i3] = startPositions[i3] + (target[i3] - startPositions[i3]) * tweenObj.t;
                        posAttr.array[i3+1] = startPositions[i3+1] + (target[i3+1] - startPositions[i3+1]) * tweenObj.t;
                        posAttr.array[i3+2] = startPositions[i3+2] + (target[i3+2] - startPositions[i3+2]) * tweenObj.t;
                    }
                    posAttr.needsUpdate = true;
                })
                .start();
                
            // Switch State
            currentShape = currentShape === 'rose' ? 'heart' : 'rose';
            
            // Update UI Text
            const h2 = document.querySelector('h2');
            if(currentShape === 'heart') {
                h2.innerText = "YOU ARE MY HEART";
                h2.style.color = "#ff0000";
                CONFIG.bloomStrength = 3.0; // Intensify glow
            } else {
                h2.innerText = "MY PRINCESS";
                h2.style.color = "#d4af37";
                CONFIG.bloomStrength = 2.0;
            }
        }

        // Click Listener
        document.getElementById('click-trigger').addEventListener('click', transformShape);

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();
        
        // Remove Loader
        setTimeout(() => {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => { document.getElementById('loader').style.display = 'none'; }, 1000);
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            TWEEN.update();
            controls.update();
            
            // Update Uniforms
            material.uniforms.uTime.value = time;
            bloomPass.strength = CONFIG.bloomStrength;

            // Gentle Float
            particleSystem.rotation.y = time * 0.05;
            particleSystem.position.y = Math.sin(time * 0.5) * 0.5;

            composer.render();
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
